// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: xla/tsl/protobuf/coordination_config.proto
// Protobuf Java Version: 4.28.3

package org.tensorflow.proto;

public final class CoordinationConfig {
  private CoordinationConfig() {}
  static {
    com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
      com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
      /* major= */ 4,
      /* minor= */ 28,
      /* patch= */ 3,
      /* suffix= */ "",
      CoordinationConfig.class.getName());
  }
  public static void registerAllExtensions(
      com.google.protobuf.ExtensionRegistryLite registry) {
  }

  public static void registerAllExtensions(
      com.google.protobuf.ExtensionRegistry registry) {
    registerAllExtensions(
        (com.google.protobuf.ExtensionRegistryLite) registry);
  }
  public interface CoordinatedJobOrBuilder extends
      // @@protoc_insertion_point(interface_extends:tensorflow.CoordinatedJob)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <code>string name = 1;</code>
     * @return The name.
     */
    java.lang.String getName();
    /**
     * <code>string name = 1;</code>
     * @return The bytes for name.
     */
    com.google.protobuf.ByteString
        getNameBytes();

    /**
     * <code>int32 num_tasks = 2;</code>
     * @return The numTasks.
     */
    int getNumTasks();
  }
  /**
   * <pre>
   * Represents a job type and the number of tasks under this job.
   * For example, ("worker", 20) implies that there will be 20 worker tasks.
   * </pre>
   *
   * Protobuf type {@code tensorflow.CoordinatedJob}
   */
  public static final class CoordinatedJob extends
      com.google.protobuf.GeneratedMessage implements
      // @@protoc_insertion_point(message_implements:tensorflow.CoordinatedJob)
      CoordinatedJobOrBuilder {
  private static final long serialVersionUID = 0L;
    static {
      com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
        com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
        /* major= */ 4,
        /* minor= */ 28,
        /* patch= */ 3,
        /* suffix= */ "",
        CoordinatedJob.class.getName());
    }
    // Use CoordinatedJob.newBuilder() to construct.
    private CoordinatedJob(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
      super(builder);
    }
    private CoordinatedJob() {
      name_ = "";
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return org.tensorflow.proto.CoordinationConfig.internal_static_tensorflow_CoordinatedJob_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return org.tensorflow.proto.CoordinationConfig.internal_static_tensorflow_CoordinatedJob_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              org.tensorflow.proto.CoordinationConfig.CoordinatedJob.class, org.tensorflow.proto.CoordinationConfig.CoordinatedJob.Builder.class);
    }

    public static final int NAME_FIELD_NUMBER = 1;
    @SuppressWarnings("serial")
    private volatile java.lang.Object name_ = "";
    /**
     * <code>string name = 1;</code>
     * @return The name.
     */
    @java.lang.Override
    public java.lang.String getName() {
      java.lang.Object ref = name_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        name_ = s;
        return s;
      }
    }
    /**
     * <code>string name = 1;</code>
     * @return The bytes for name.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getNameBytes() {
      java.lang.Object ref = name_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        name_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int NUM_TASKS_FIELD_NUMBER = 2;
    private int numTasks_ = 0;
    /**
     * <code>int32 num_tasks = 2;</code>
     * @return The numTasks.
     */
    @java.lang.Override
    public int getNumTasks() {
      return numTasks_;
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (!com.google.protobuf.GeneratedMessage.isStringEmpty(name_)) {
        com.google.protobuf.GeneratedMessage.writeString(output, 1, name_);
      }
      if (numTasks_ != 0) {
        output.writeInt32(2, numTasks_);
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (!com.google.protobuf.GeneratedMessage.isStringEmpty(name_)) {
        size += com.google.protobuf.GeneratedMessage.computeStringSize(1, name_);
      }
      if (numTasks_ != 0) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(2, numTasks_);
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof org.tensorflow.proto.CoordinationConfig.CoordinatedJob)) {
        return super.equals(obj);
      }
      org.tensorflow.proto.CoordinationConfig.CoordinatedJob other = (org.tensorflow.proto.CoordinationConfig.CoordinatedJob) obj;

      if (!getName()
          .equals(other.getName())) return false;
      if (getNumTasks()
          != other.getNumTasks()) return false;
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (37 * hash) + NAME_FIELD_NUMBER;
      hash = (53 * hash) + getName().hashCode();
      hash = (37 * hash) + NUM_TASKS_FIELD_NUMBER;
      hash = (53 * hash) + getNumTasks();
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static org.tensorflow.proto.CoordinationConfig.CoordinatedJob parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static org.tensorflow.proto.CoordinationConfig.CoordinatedJob parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static org.tensorflow.proto.CoordinationConfig.CoordinatedJob parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static org.tensorflow.proto.CoordinationConfig.CoordinatedJob parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static org.tensorflow.proto.CoordinationConfig.CoordinatedJob parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static org.tensorflow.proto.CoordinationConfig.CoordinatedJob parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static org.tensorflow.proto.CoordinationConfig.CoordinatedJob parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static org.tensorflow.proto.CoordinationConfig.CoordinatedJob parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static org.tensorflow.proto.CoordinationConfig.CoordinatedJob parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static org.tensorflow.proto.CoordinationConfig.CoordinatedJob parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static org.tensorflow.proto.CoordinationConfig.CoordinatedJob parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static org.tensorflow.proto.CoordinationConfig.CoordinatedJob parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(org.tensorflow.proto.CoordinationConfig.CoordinatedJob prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessage.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * Represents a job type and the number of tasks under this job.
     * For example, ("worker", 20) implies that there will be 20 worker tasks.
     * </pre>
     *
     * Protobuf type {@code tensorflow.CoordinatedJob}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessage.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:tensorflow.CoordinatedJob)
        org.tensorflow.proto.CoordinationConfig.CoordinatedJobOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return org.tensorflow.proto.CoordinationConfig.internal_static_tensorflow_CoordinatedJob_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return org.tensorflow.proto.CoordinationConfig.internal_static_tensorflow_CoordinatedJob_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                org.tensorflow.proto.CoordinationConfig.CoordinatedJob.class, org.tensorflow.proto.CoordinationConfig.CoordinatedJob.Builder.class);
      }

      // Construct using org.tensorflow.proto.CoordinationConfig.CoordinatedJob.newBuilder()
      private Builder() {

      }

      private Builder(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        super(parent);

      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        name_ = "";
        numTasks_ = 0;
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return org.tensorflow.proto.CoordinationConfig.internal_static_tensorflow_CoordinatedJob_descriptor;
      }

      @java.lang.Override
      public org.tensorflow.proto.CoordinationConfig.CoordinatedJob getDefaultInstanceForType() {
        return org.tensorflow.proto.CoordinationConfig.CoordinatedJob.getDefaultInstance();
      }

      @java.lang.Override
      public org.tensorflow.proto.CoordinationConfig.CoordinatedJob build() {
        org.tensorflow.proto.CoordinationConfig.CoordinatedJob result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public org.tensorflow.proto.CoordinationConfig.CoordinatedJob buildPartial() {
        org.tensorflow.proto.CoordinationConfig.CoordinatedJob result = new org.tensorflow.proto.CoordinationConfig.CoordinatedJob(this);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartial0(org.tensorflow.proto.CoordinationConfig.CoordinatedJob result) {
        int from_bitField0_ = bitField0_;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.name_ = name_;
        }
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.numTasks_ = numTasks_;
        }
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof org.tensorflow.proto.CoordinationConfig.CoordinatedJob) {
          return mergeFrom((org.tensorflow.proto.CoordinationConfig.CoordinatedJob)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(org.tensorflow.proto.CoordinationConfig.CoordinatedJob other) {
        if (other == org.tensorflow.proto.CoordinationConfig.CoordinatedJob.getDefaultInstance()) return this;
        if (!other.getName().isEmpty()) {
          name_ = other.name_;
          bitField0_ |= 0x00000001;
          onChanged();
        }
        if (other.getNumTasks() != 0) {
          setNumTasks(other.getNumTasks());
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                name_ = input.readStringRequireUtf8();
                bitField0_ |= 0x00000001;
                break;
              } // case 10
              case 16: {
                numTasks_ = input.readInt32();
                bitField0_ |= 0x00000002;
                break;
              } // case 16
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private java.lang.Object name_ = "";
      /**
       * <code>string name = 1;</code>
       * @return The name.
       */
      public java.lang.String getName() {
        java.lang.Object ref = name_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          name_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <code>string name = 1;</code>
       * @return The bytes for name.
       */
      public com.google.protobuf.ByteString
          getNameBytes() {
        java.lang.Object ref = name_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          name_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <code>string name = 1;</code>
       * @param value The name to set.
       * @return This builder for chaining.
       */
      public Builder setName(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        name_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <code>string name = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearName() {
        name_ = getDefaultInstance().getName();
        bitField0_ = (bitField0_ & ~0x00000001);
        onChanged();
        return this;
      }
      /**
       * <code>string name = 1;</code>
       * @param value The bytes for name to set.
       * @return This builder for chaining.
       */
      public Builder setNameBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        checkByteStringIsUtf8(value);
        name_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }

      private int numTasks_ ;
      /**
       * <code>int32 num_tasks = 2;</code>
       * @return The numTasks.
       */
      @java.lang.Override
      public int getNumTasks() {
        return numTasks_;
      }
      /**
       * <code>int32 num_tasks = 2;</code>
       * @param value The numTasks to set.
       * @return This builder for chaining.
       */
      public Builder setNumTasks(int value) {

        numTasks_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <code>int32 num_tasks = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearNumTasks() {
        bitField0_ = (bitField0_ & ~0x00000002);
        numTasks_ = 0;
        onChanged();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:tensorflow.CoordinatedJob)
    }

    // @@protoc_insertion_point(class_scope:tensorflow.CoordinatedJob)
    private static final org.tensorflow.proto.CoordinationConfig.CoordinatedJob DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new org.tensorflow.proto.CoordinationConfig.CoordinatedJob();
    }

    public static org.tensorflow.proto.CoordinationConfig.CoordinatedJob getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<CoordinatedJob>
        PARSER = new com.google.protobuf.AbstractParser<CoordinatedJob>() {
      @java.lang.Override
      public CoordinatedJob parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<CoordinatedJob> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<CoordinatedJob> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public org.tensorflow.proto.CoordinationConfig.CoordinatedJob getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface CoordinationServiceConfigOrBuilder extends
      // @@protoc_insertion_point(interface_extends:tensorflow.CoordinationServiceConfig)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * Type of coordination service implementation to enable.
     * For example, setting the service type as "standalone" starts a service
     * instance on the leader task to provide the coordination services such as
     * heartbeats and consistent key-value store.
     * </pre>
     *
     * <code>string service_type = 1;</code>
     * @return The serviceType.
     */
    java.lang.String getServiceType();
    /**
     * <pre>
     * Type of coordination service implementation to enable.
     * For example, setting the service type as "standalone" starts a service
     * instance on the leader task to provide the coordination services such as
     * heartbeats and consistent key-value store.
     * </pre>
     *
     * <code>string service_type = 1;</code>
     * @return The bytes for serviceType.
     */
    com.google.protobuf.ByteString
        getServiceTypeBytes();

    /**
     * <pre>
     * Address where the coordination service instance is hosted.
     * </pre>
     *
     * <code>string service_leader = 2;</code>
     * @return The serviceLeader.
     */
    java.lang.String getServiceLeader();
    /**
     * <pre>
     * Address where the coordination service instance is hosted.
     * </pre>
     *
     * <code>string service_leader = 2;</code>
     * @return The bytes for serviceLeader.
     */
    com.google.protobuf.ByteString
        getServiceLeaderBytes();

    /**
     * <pre>
     * Whether to enable the health check mechanism.
     * </pre>
     *
     * <code>bool enable_health_check = 3;</code>
     * @return The enableHealthCheck.
     */
    boolean getEnableHealthCheck();

    /**
     * <pre>
     * Maximum wait time for all members in the cluster to be registered.
     * </pre>
     *
     * <code>int64 cluster_register_timeout_in_ms = 4;</code>
     * @return The clusterRegisterTimeoutInMs.
     */
    long getClusterRegisterTimeoutInMs();

    /**
     * <pre>
     * Denotes if we should synchronize the agents' register attempts by blocking
     * on a barrier. This is useful for synchronized restarts.
     * </pre>
     *
     * <code>bool cluster_register_with_barrier = 14;</code>
     * @return The clusterRegisterWithBarrier.
     */
    boolean getClusterRegisterWithBarrier();

    /**
     * <pre>
     * Heartbeat timeout, if a task does not record heartbeat in this time
     * window, it will be considered disconnected.
     * Note: This is also used as a grace period to accept any heartbeats after
     * the agent has disconnected, to account for the lag time between the service
     * recording the state change and the agent stopping heartbeats.
     * </pre>
     *
     * <code>int64 heartbeat_timeout_in_ms = 5;</code>
     * @return The heartbeatTimeoutInMs.
     */
    long getHeartbeatTimeoutInMs();

    /**
     * <code>repeated .tensorflow.CoordinatedJob coordinated_job_list = 10;</code>
     */
    java.util.List<org.tensorflow.proto.CoordinationConfig.CoordinatedJob> 
        getCoordinatedJobListList();
    /**
     * <code>repeated .tensorflow.CoordinatedJob coordinated_job_list = 10;</code>
     */
    org.tensorflow.proto.CoordinationConfig.CoordinatedJob getCoordinatedJobList(int index);
    /**
     * <code>repeated .tensorflow.CoordinatedJob coordinated_job_list = 10;</code>
     */
    int getCoordinatedJobListCount();
    /**
     * <code>repeated .tensorflow.CoordinatedJob coordinated_job_list = 10;</code>
     */
    java.util.List<? extends org.tensorflow.proto.CoordinationConfig.CoordinatedJobOrBuilder> 
        getCoordinatedJobListOrBuilderList();
    /**
     * <code>repeated .tensorflow.CoordinatedJob coordinated_job_list = 10;</code>
     */
    org.tensorflow.proto.CoordinationConfig.CoordinatedJobOrBuilder getCoordinatedJobListOrBuilder(
        int index);

    /**
     * <pre>
     * Denotes how long to wait for all coordination agents to reach the barriers
     * (after the first shutdown request) before disconnecting together. If
     * set to 0, no barrier is imposed upon shutdown and each worker can
     * disconnect individually.
     * </pre>
     *
     * <code>int64 shutdown_barrier_timeout_in_ms = 7;</code>
     * @return The shutdownBarrierTimeoutInMs.
     */
    long getShutdownBarrierTimeoutInMs();

    /**
     * <pre>
     * If set, agents do not make an explicit Shutdown() call. Service will only
     * find out about the disconnecte agent via stale heartbeats. Used for
     * testing.
     * </pre>
     *
     * <code>bool agent_destruction_without_shutdown = 8;</code>
     * @return The agentDestructionWithoutShutdown.
     */
    boolean getAgentDestructionWithoutShutdown();

    /**
     * <pre>
     * The list of jobs which are recoverable. If a task in this list fails,
     * it will not propagate error to other tasks.
     * If empty, no jobs will be recoverable and every task failure will cause
     * error propagation to other tasks.
     * </pre>
     *
     * <code>repeated string recoverable_jobs = 9;</code>
     * @return A list containing the recoverableJobs.
     */
    java.util.List<java.lang.String>
        getRecoverableJobsList();
    /**
     * <pre>
     * The list of jobs which are recoverable. If a task in this list fails,
     * it will not propagate error to other tasks.
     * If empty, no jobs will be recoverable and every task failure will cause
     * error propagation to other tasks.
     * </pre>
     *
     * <code>repeated string recoverable_jobs = 9;</code>
     * @return The count of recoverableJobs.
     */
    int getRecoverableJobsCount();
    /**
     * <pre>
     * The list of jobs which are recoverable. If a task in this list fails,
     * it will not propagate error to other tasks.
     * If empty, no jobs will be recoverable and every task failure will cause
     * error propagation to other tasks.
     * </pre>
     *
     * <code>repeated string recoverable_jobs = 9;</code>
     * @param index The index of the element to return.
     * @return The recoverableJobs at the given index.
     */
    java.lang.String getRecoverableJobs(int index);
    /**
     * <pre>
     * The list of jobs which are recoverable. If a task in this list fails,
     * it will not propagate error to other tasks.
     * If empty, no jobs will be recoverable and every task failure will cause
     * error propagation to other tasks.
     * </pre>
     *
     * <code>repeated string recoverable_jobs = 9;</code>
     * @param index The index of the value to return.
     * @return The bytes of the recoverableJobs at the given index.
     */
    com.google.protobuf.ByteString
        getRecoverableJobsBytes(int index);

    /**
     * <pre>
     * If a task restarts with a new incarnation, we may allow it to reconnect
     * silently. This is useful when we know that a task can immediately resume
     * work upon re-connecting to the service.
     * </pre>
     *
     * <code>bool allow_new_incarnation_to_reconnect = 11;</code>
     * @return The allowNewIncarnationToReconnect.
     */
    boolean getAllowNewIncarnationToReconnect();

    /**
     * <pre>
     * Disables coordination service.
     * Some libraries enable coordination service by default even if the user did
     * not specify any config. This field allows users to explicitly disable
     * coordination service under all situations.
     * </pre>
     *
     * <code>bool force_disable = 12;</code>
     * @return The forceDisable.
     */
    boolean getForceDisable();

    /**
     * <pre>
     * Use long polling to get error from coordination service as the error
     * propagation mechanism.
     * </pre>
     *
     * <code>bool poll_for_error_from_service_at_startup = 13;</code>
     * @return The pollForErrorFromServiceAtStartup.
     */
    boolean getPollForErrorFromServiceAtStartup();
  }
  /**
   * <pre>
   * Coordination service configuration parameters.
   * The system picks appropriate values for fields that are not set.
   * </pre>
   *
   * Protobuf type {@code tensorflow.CoordinationServiceConfig}
   */
  public static final class CoordinationServiceConfig extends
      com.google.protobuf.GeneratedMessage implements
      // @@protoc_insertion_point(message_implements:tensorflow.CoordinationServiceConfig)
      CoordinationServiceConfigOrBuilder {
  private static final long serialVersionUID = 0L;
    static {
      com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
        com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
        /* major= */ 4,
        /* minor= */ 28,
        /* patch= */ 3,
        /* suffix= */ "",
        CoordinationServiceConfig.class.getName());
    }
    // Use CoordinationServiceConfig.newBuilder() to construct.
    private CoordinationServiceConfig(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
      super(builder);
    }
    private CoordinationServiceConfig() {
      serviceType_ = "";
      serviceLeader_ = "";
      coordinatedJobList_ = java.util.Collections.emptyList();
      recoverableJobs_ =
          com.google.protobuf.LazyStringArrayList.emptyList();
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return org.tensorflow.proto.CoordinationConfig.internal_static_tensorflow_CoordinationServiceConfig_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return org.tensorflow.proto.CoordinationConfig.internal_static_tensorflow_CoordinationServiceConfig_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              org.tensorflow.proto.CoordinationConfig.CoordinationServiceConfig.class, org.tensorflow.proto.CoordinationConfig.CoordinationServiceConfig.Builder.class);
    }

    public static final int SERVICE_TYPE_FIELD_NUMBER = 1;
    @SuppressWarnings("serial")
    private volatile java.lang.Object serviceType_ = "";
    /**
     * <pre>
     * Type of coordination service implementation to enable.
     * For example, setting the service type as "standalone" starts a service
     * instance on the leader task to provide the coordination services such as
     * heartbeats and consistent key-value store.
     * </pre>
     *
     * <code>string service_type = 1;</code>
     * @return The serviceType.
     */
    @java.lang.Override
    public java.lang.String getServiceType() {
      java.lang.Object ref = serviceType_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        serviceType_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * Type of coordination service implementation to enable.
     * For example, setting the service type as "standalone" starts a service
     * instance on the leader task to provide the coordination services such as
     * heartbeats and consistent key-value store.
     * </pre>
     *
     * <code>string service_type = 1;</code>
     * @return The bytes for serviceType.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getServiceTypeBytes() {
      java.lang.Object ref = serviceType_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        serviceType_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int SERVICE_LEADER_FIELD_NUMBER = 2;
    @SuppressWarnings("serial")
    private volatile java.lang.Object serviceLeader_ = "";
    /**
     * <pre>
     * Address where the coordination service instance is hosted.
     * </pre>
     *
     * <code>string service_leader = 2;</code>
     * @return The serviceLeader.
     */
    @java.lang.Override
    public java.lang.String getServiceLeader() {
      java.lang.Object ref = serviceLeader_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        serviceLeader_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * Address where the coordination service instance is hosted.
     * </pre>
     *
     * <code>string service_leader = 2;</code>
     * @return The bytes for serviceLeader.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getServiceLeaderBytes() {
      java.lang.Object ref = serviceLeader_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        serviceLeader_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int ENABLE_HEALTH_CHECK_FIELD_NUMBER = 3;
    private boolean enableHealthCheck_ = false;
    /**
     * <pre>
     * Whether to enable the health check mechanism.
     * </pre>
     *
     * <code>bool enable_health_check = 3;</code>
     * @return The enableHealthCheck.
     */
    @java.lang.Override
    public boolean getEnableHealthCheck() {
      return enableHealthCheck_;
    }

    public static final int CLUSTER_REGISTER_TIMEOUT_IN_MS_FIELD_NUMBER = 4;
    private long clusterRegisterTimeoutInMs_ = 0L;
    /**
     * <pre>
     * Maximum wait time for all members in the cluster to be registered.
     * </pre>
     *
     * <code>int64 cluster_register_timeout_in_ms = 4;</code>
     * @return The clusterRegisterTimeoutInMs.
     */
    @java.lang.Override
    public long getClusterRegisterTimeoutInMs() {
      return clusterRegisterTimeoutInMs_;
    }

    public static final int CLUSTER_REGISTER_WITH_BARRIER_FIELD_NUMBER = 14;
    private boolean clusterRegisterWithBarrier_ = false;
    /**
     * <pre>
     * Denotes if we should synchronize the agents' register attempts by blocking
     * on a barrier. This is useful for synchronized restarts.
     * </pre>
     *
     * <code>bool cluster_register_with_barrier = 14;</code>
     * @return The clusterRegisterWithBarrier.
     */
    @java.lang.Override
    public boolean getClusterRegisterWithBarrier() {
      return clusterRegisterWithBarrier_;
    }

    public static final int HEARTBEAT_TIMEOUT_IN_MS_FIELD_NUMBER = 5;
    private long heartbeatTimeoutInMs_ = 0L;
    /**
     * <pre>
     * Heartbeat timeout, if a task does not record heartbeat in this time
     * window, it will be considered disconnected.
     * Note: This is also used as a grace period to accept any heartbeats after
     * the agent has disconnected, to account for the lag time between the service
     * recording the state change and the agent stopping heartbeats.
     * </pre>
     *
     * <code>int64 heartbeat_timeout_in_ms = 5;</code>
     * @return The heartbeatTimeoutInMs.
     */
    @java.lang.Override
    public long getHeartbeatTimeoutInMs() {
      return heartbeatTimeoutInMs_;
    }

    public static final int COORDINATED_JOB_LIST_FIELD_NUMBER = 10;
    @SuppressWarnings("serial")
    private java.util.List<org.tensorflow.proto.CoordinationConfig.CoordinatedJob> coordinatedJobList_;
    /**
     * <code>repeated .tensorflow.CoordinatedJob coordinated_job_list = 10;</code>
     */
    @java.lang.Override
    public java.util.List<org.tensorflow.proto.CoordinationConfig.CoordinatedJob> getCoordinatedJobListList() {
      return coordinatedJobList_;
    }
    /**
     * <code>repeated .tensorflow.CoordinatedJob coordinated_job_list = 10;</code>
     */
    @java.lang.Override
    public java.util.List<? extends org.tensorflow.proto.CoordinationConfig.CoordinatedJobOrBuilder> 
        getCoordinatedJobListOrBuilderList() {
      return coordinatedJobList_;
    }
    /**
     * <code>repeated .tensorflow.CoordinatedJob coordinated_job_list = 10;</code>
     */
    @java.lang.Override
    public int getCoordinatedJobListCount() {
      return coordinatedJobList_.size();
    }
    /**
     * <code>repeated .tensorflow.CoordinatedJob coordinated_job_list = 10;</code>
     */
    @java.lang.Override
    public org.tensorflow.proto.CoordinationConfig.CoordinatedJob getCoordinatedJobList(int index) {
      return coordinatedJobList_.get(index);
    }
    /**
     * <code>repeated .tensorflow.CoordinatedJob coordinated_job_list = 10;</code>
     */
    @java.lang.Override
    public org.tensorflow.proto.CoordinationConfig.CoordinatedJobOrBuilder getCoordinatedJobListOrBuilder(
        int index) {
      return coordinatedJobList_.get(index);
    }

    public static final int SHUTDOWN_BARRIER_TIMEOUT_IN_MS_FIELD_NUMBER = 7;
    private long shutdownBarrierTimeoutInMs_ = 0L;
    /**
     * <pre>
     * Denotes how long to wait for all coordination agents to reach the barriers
     * (after the first shutdown request) before disconnecting together. If
     * set to 0, no barrier is imposed upon shutdown and each worker can
     * disconnect individually.
     * </pre>
     *
     * <code>int64 shutdown_barrier_timeout_in_ms = 7;</code>
     * @return The shutdownBarrierTimeoutInMs.
     */
    @java.lang.Override
    public long getShutdownBarrierTimeoutInMs() {
      return shutdownBarrierTimeoutInMs_;
    }

    public static final int AGENT_DESTRUCTION_WITHOUT_SHUTDOWN_FIELD_NUMBER = 8;
    private boolean agentDestructionWithoutShutdown_ = false;
    /**
     * <pre>
     * If set, agents do not make an explicit Shutdown() call. Service will only
     * find out about the disconnecte agent via stale heartbeats. Used for
     * testing.
     * </pre>
     *
     * <code>bool agent_destruction_without_shutdown = 8;</code>
     * @return The agentDestructionWithoutShutdown.
     */
    @java.lang.Override
    public boolean getAgentDestructionWithoutShutdown() {
      return agentDestructionWithoutShutdown_;
    }

    public static final int RECOVERABLE_JOBS_FIELD_NUMBER = 9;
    @SuppressWarnings("serial")
    private com.google.protobuf.LazyStringArrayList recoverableJobs_ =
        com.google.protobuf.LazyStringArrayList.emptyList();
    /**
     * <pre>
     * The list of jobs which are recoverable. If a task in this list fails,
     * it will not propagate error to other tasks.
     * If empty, no jobs will be recoverable and every task failure will cause
     * error propagation to other tasks.
     * </pre>
     *
     * <code>repeated string recoverable_jobs = 9;</code>
     * @return A list containing the recoverableJobs.
     */
    public com.google.protobuf.ProtocolStringList
        getRecoverableJobsList() {
      return recoverableJobs_;
    }
    /**
     * <pre>
     * The list of jobs which are recoverable. If a task in this list fails,
     * it will not propagate error to other tasks.
     * If empty, no jobs will be recoverable and every task failure will cause
     * error propagation to other tasks.
     * </pre>
     *
     * <code>repeated string recoverable_jobs = 9;</code>
     * @return The count of recoverableJobs.
     */
    public int getRecoverableJobsCount() {
      return recoverableJobs_.size();
    }
    /**
     * <pre>
     * The list of jobs which are recoverable. If a task in this list fails,
     * it will not propagate error to other tasks.
     * If empty, no jobs will be recoverable and every task failure will cause
     * error propagation to other tasks.
     * </pre>
     *
     * <code>repeated string recoverable_jobs = 9;</code>
     * @param index The index of the element to return.
     * @return The recoverableJobs at the given index.
     */
    public java.lang.String getRecoverableJobs(int index) {
      return recoverableJobs_.get(index);
    }
    /**
     * <pre>
     * The list of jobs which are recoverable. If a task in this list fails,
     * it will not propagate error to other tasks.
     * If empty, no jobs will be recoverable and every task failure will cause
     * error propagation to other tasks.
     * </pre>
     *
     * <code>repeated string recoverable_jobs = 9;</code>
     * @param index The index of the value to return.
     * @return The bytes of the recoverableJobs at the given index.
     */
    public com.google.protobuf.ByteString
        getRecoverableJobsBytes(int index) {
      return recoverableJobs_.getByteString(index);
    }

    public static final int ALLOW_NEW_INCARNATION_TO_RECONNECT_FIELD_NUMBER = 11;
    private boolean allowNewIncarnationToReconnect_ = false;
    /**
     * <pre>
     * If a task restarts with a new incarnation, we may allow it to reconnect
     * silently. This is useful when we know that a task can immediately resume
     * work upon re-connecting to the service.
     * </pre>
     *
     * <code>bool allow_new_incarnation_to_reconnect = 11;</code>
     * @return The allowNewIncarnationToReconnect.
     */
    @java.lang.Override
    public boolean getAllowNewIncarnationToReconnect() {
      return allowNewIncarnationToReconnect_;
    }

    public static final int FORCE_DISABLE_FIELD_NUMBER = 12;
    private boolean forceDisable_ = false;
    /**
     * <pre>
     * Disables coordination service.
     * Some libraries enable coordination service by default even if the user did
     * not specify any config. This field allows users to explicitly disable
     * coordination service under all situations.
     * </pre>
     *
     * <code>bool force_disable = 12;</code>
     * @return The forceDisable.
     */
    @java.lang.Override
    public boolean getForceDisable() {
      return forceDisable_;
    }

    public static final int POLL_FOR_ERROR_FROM_SERVICE_AT_STARTUP_FIELD_NUMBER = 13;
    private boolean pollForErrorFromServiceAtStartup_ = false;
    /**
     * <pre>
     * Use long polling to get error from coordination service as the error
     * propagation mechanism.
     * </pre>
     *
     * <code>bool poll_for_error_from_service_at_startup = 13;</code>
     * @return The pollForErrorFromServiceAtStartup.
     */
    @java.lang.Override
    public boolean getPollForErrorFromServiceAtStartup() {
      return pollForErrorFromServiceAtStartup_;
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (!com.google.protobuf.GeneratedMessage.isStringEmpty(serviceType_)) {
        com.google.protobuf.GeneratedMessage.writeString(output, 1, serviceType_);
      }
      if (!com.google.protobuf.GeneratedMessage.isStringEmpty(serviceLeader_)) {
        com.google.protobuf.GeneratedMessage.writeString(output, 2, serviceLeader_);
      }
      if (enableHealthCheck_ != false) {
        output.writeBool(3, enableHealthCheck_);
      }
      if (clusterRegisterTimeoutInMs_ != 0L) {
        output.writeInt64(4, clusterRegisterTimeoutInMs_);
      }
      if (heartbeatTimeoutInMs_ != 0L) {
        output.writeInt64(5, heartbeatTimeoutInMs_);
      }
      if (shutdownBarrierTimeoutInMs_ != 0L) {
        output.writeInt64(7, shutdownBarrierTimeoutInMs_);
      }
      if (agentDestructionWithoutShutdown_ != false) {
        output.writeBool(8, agentDestructionWithoutShutdown_);
      }
      for (int i = 0; i < recoverableJobs_.size(); i++) {
        com.google.protobuf.GeneratedMessage.writeString(output, 9, recoverableJobs_.getRaw(i));
      }
      for (int i = 0; i < coordinatedJobList_.size(); i++) {
        output.writeMessage(10, coordinatedJobList_.get(i));
      }
      if (allowNewIncarnationToReconnect_ != false) {
        output.writeBool(11, allowNewIncarnationToReconnect_);
      }
      if (forceDisable_ != false) {
        output.writeBool(12, forceDisable_);
      }
      if (pollForErrorFromServiceAtStartup_ != false) {
        output.writeBool(13, pollForErrorFromServiceAtStartup_);
      }
      if (clusterRegisterWithBarrier_ != false) {
        output.writeBool(14, clusterRegisterWithBarrier_);
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (!com.google.protobuf.GeneratedMessage.isStringEmpty(serviceType_)) {
        size += com.google.protobuf.GeneratedMessage.computeStringSize(1, serviceType_);
      }
      if (!com.google.protobuf.GeneratedMessage.isStringEmpty(serviceLeader_)) {
        size += com.google.protobuf.GeneratedMessage.computeStringSize(2, serviceLeader_);
      }
      if (enableHealthCheck_ != false) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(3, enableHealthCheck_);
      }
      if (clusterRegisterTimeoutInMs_ != 0L) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt64Size(4, clusterRegisterTimeoutInMs_);
      }
      if (heartbeatTimeoutInMs_ != 0L) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt64Size(5, heartbeatTimeoutInMs_);
      }
      if (shutdownBarrierTimeoutInMs_ != 0L) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt64Size(7, shutdownBarrierTimeoutInMs_);
      }
      if (agentDestructionWithoutShutdown_ != false) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(8, agentDestructionWithoutShutdown_);
      }
      {
        int dataSize = 0;
        for (int i = 0; i < recoverableJobs_.size(); i++) {
          dataSize += computeStringSizeNoTag(recoverableJobs_.getRaw(i));
        }
        size += dataSize;
        size += 1 * getRecoverableJobsList().size();
      }
      for (int i = 0; i < coordinatedJobList_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(10, coordinatedJobList_.get(i));
      }
      if (allowNewIncarnationToReconnect_ != false) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(11, allowNewIncarnationToReconnect_);
      }
      if (forceDisable_ != false) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(12, forceDisable_);
      }
      if (pollForErrorFromServiceAtStartup_ != false) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(13, pollForErrorFromServiceAtStartup_);
      }
      if (clusterRegisterWithBarrier_ != false) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(14, clusterRegisterWithBarrier_);
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof org.tensorflow.proto.CoordinationConfig.CoordinationServiceConfig)) {
        return super.equals(obj);
      }
      org.tensorflow.proto.CoordinationConfig.CoordinationServiceConfig other = (org.tensorflow.proto.CoordinationConfig.CoordinationServiceConfig) obj;

      if (!getServiceType()
          .equals(other.getServiceType())) return false;
      if (!getServiceLeader()
          .equals(other.getServiceLeader())) return false;
      if (getEnableHealthCheck()
          != other.getEnableHealthCheck()) return false;
      if (getClusterRegisterTimeoutInMs()
          != other.getClusterRegisterTimeoutInMs()) return false;
      if (getClusterRegisterWithBarrier()
          != other.getClusterRegisterWithBarrier()) return false;
      if (getHeartbeatTimeoutInMs()
          != other.getHeartbeatTimeoutInMs()) return false;
      if (!getCoordinatedJobListList()
          .equals(other.getCoordinatedJobListList())) return false;
      if (getShutdownBarrierTimeoutInMs()
          != other.getShutdownBarrierTimeoutInMs()) return false;
      if (getAgentDestructionWithoutShutdown()
          != other.getAgentDestructionWithoutShutdown()) return false;
      if (!getRecoverableJobsList()
          .equals(other.getRecoverableJobsList())) return false;
      if (getAllowNewIncarnationToReconnect()
          != other.getAllowNewIncarnationToReconnect()) return false;
      if (getForceDisable()
          != other.getForceDisable()) return false;
      if (getPollForErrorFromServiceAtStartup()
          != other.getPollForErrorFromServiceAtStartup()) return false;
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (37 * hash) + SERVICE_TYPE_FIELD_NUMBER;
      hash = (53 * hash) + getServiceType().hashCode();
      hash = (37 * hash) + SERVICE_LEADER_FIELD_NUMBER;
      hash = (53 * hash) + getServiceLeader().hashCode();
      hash = (37 * hash) + ENABLE_HEALTH_CHECK_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
          getEnableHealthCheck());
      hash = (37 * hash) + CLUSTER_REGISTER_TIMEOUT_IN_MS_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
          getClusterRegisterTimeoutInMs());
      hash = (37 * hash) + CLUSTER_REGISTER_WITH_BARRIER_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
          getClusterRegisterWithBarrier());
      hash = (37 * hash) + HEARTBEAT_TIMEOUT_IN_MS_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
          getHeartbeatTimeoutInMs());
      if (getCoordinatedJobListCount() > 0) {
        hash = (37 * hash) + COORDINATED_JOB_LIST_FIELD_NUMBER;
        hash = (53 * hash) + getCoordinatedJobListList().hashCode();
      }
      hash = (37 * hash) + SHUTDOWN_BARRIER_TIMEOUT_IN_MS_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
          getShutdownBarrierTimeoutInMs());
      hash = (37 * hash) + AGENT_DESTRUCTION_WITHOUT_SHUTDOWN_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
          getAgentDestructionWithoutShutdown());
      if (getRecoverableJobsCount() > 0) {
        hash = (37 * hash) + RECOVERABLE_JOBS_FIELD_NUMBER;
        hash = (53 * hash) + getRecoverableJobsList().hashCode();
      }
      hash = (37 * hash) + ALLOW_NEW_INCARNATION_TO_RECONNECT_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
          getAllowNewIncarnationToReconnect());
      hash = (37 * hash) + FORCE_DISABLE_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
          getForceDisable());
      hash = (37 * hash) + POLL_FOR_ERROR_FROM_SERVICE_AT_STARTUP_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
          getPollForErrorFromServiceAtStartup());
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static org.tensorflow.proto.CoordinationConfig.CoordinationServiceConfig parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static org.tensorflow.proto.CoordinationConfig.CoordinationServiceConfig parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static org.tensorflow.proto.CoordinationConfig.CoordinationServiceConfig parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static org.tensorflow.proto.CoordinationConfig.CoordinationServiceConfig parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static org.tensorflow.proto.CoordinationConfig.CoordinationServiceConfig parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static org.tensorflow.proto.CoordinationConfig.CoordinationServiceConfig parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static org.tensorflow.proto.CoordinationConfig.CoordinationServiceConfig parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static org.tensorflow.proto.CoordinationConfig.CoordinationServiceConfig parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static org.tensorflow.proto.CoordinationConfig.CoordinationServiceConfig parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static org.tensorflow.proto.CoordinationConfig.CoordinationServiceConfig parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static org.tensorflow.proto.CoordinationConfig.CoordinationServiceConfig parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static org.tensorflow.proto.CoordinationConfig.CoordinationServiceConfig parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(org.tensorflow.proto.CoordinationConfig.CoordinationServiceConfig prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessage.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * Coordination service configuration parameters.
     * The system picks appropriate values for fields that are not set.
     * </pre>
     *
     * Protobuf type {@code tensorflow.CoordinationServiceConfig}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessage.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:tensorflow.CoordinationServiceConfig)
        org.tensorflow.proto.CoordinationConfig.CoordinationServiceConfigOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return org.tensorflow.proto.CoordinationConfig.internal_static_tensorflow_CoordinationServiceConfig_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return org.tensorflow.proto.CoordinationConfig.internal_static_tensorflow_CoordinationServiceConfig_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                org.tensorflow.proto.CoordinationConfig.CoordinationServiceConfig.class, org.tensorflow.proto.CoordinationConfig.CoordinationServiceConfig.Builder.class);
      }

      // Construct using org.tensorflow.proto.CoordinationConfig.CoordinationServiceConfig.newBuilder()
      private Builder() {

      }

      private Builder(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        super(parent);

      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        serviceType_ = "";
        serviceLeader_ = "";
        enableHealthCheck_ = false;
        clusterRegisterTimeoutInMs_ = 0L;
        clusterRegisterWithBarrier_ = false;
        heartbeatTimeoutInMs_ = 0L;
        if (coordinatedJobListBuilder_ == null) {
          coordinatedJobList_ = java.util.Collections.emptyList();
        } else {
          coordinatedJobList_ = null;
          coordinatedJobListBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000040);
        shutdownBarrierTimeoutInMs_ = 0L;
        agentDestructionWithoutShutdown_ = false;
        recoverableJobs_ =
            com.google.protobuf.LazyStringArrayList.emptyList();
        allowNewIncarnationToReconnect_ = false;
        forceDisable_ = false;
        pollForErrorFromServiceAtStartup_ = false;
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return org.tensorflow.proto.CoordinationConfig.internal_static_tensorflow_CoordinationServiceConfig_descriptor;
      }

      @java.lang.Override
      public org.tensorflow.proto.CoordinationConfig.CoordinationServiceConfig getDefaultInstanceForType() {
        return org.tensorflow.proto.CoordinationConfig.CoordinationServiceConfig.getDefaultInstance();
      }

      @java.lang.Override
      public org.tensorflow.proto.CoordinationConfig.CoordinationServiceConfig build() {
        org.tensorflow.proto.CoordinationConfig.CoordinationServiceConfig result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public org.tensorflow.proto.CoordinationConfig.CoordinationServiceConfig buildPartial() {
        org.tensorflow.proto.CoordinationConfig.CoordinationServiceConfig result = new org.tensorflow.proto.CoordinationConfig.CoordinationServiceConfig(this);
        buildPartialRepeatedFields(result);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartialRepeatedFields(org.tensorflow.proto.CoordinationConfig.CoordinationServiceConfig result) {
        if (coordinatedJobListBuilder_ == null) {
          if (((bitField0_ & 0x00000040) != 0)) {
            coordinatedJobList_ = java.util.Collections.unmodifiableList(coordinatedJobList_);
            bitField0_ = (bitField0_ & ~0x00000040);
          }
          result.coordinatedJobList_ = coordinatedJobList_;
        } else {
          result.coordinatedJobList_ = coordinatedJobListBuilder_.build();
        }
      }

      private void buildPartial0(org.tensorflow.proto.CoordinationConfig.CoordinationServiceConfig result) {
        int from_bitField0_ = bitField0_;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.serviceType_ = serviceType_;
        }
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.serviceLeader_ = serviceLeader_;
        }
        if (((from_bitField0_ & 0x00000004) != 0)) {
          result.enableHealthCheck_ = enableHealthCheck_;
        }
        if (((from_bitField0_ & 0x00000008) != 0)) {
          result.clusterRegisterTimeoutInMs_ = clusterRegisterTimeoutInMs_;
        }
        if (((from_bitField0_ & 0x00000010) != 0)) {
          result.clusterRegisterWithBarrier_ = clusterRegisterWithBarrier_;
        }
        if (((from_bitField0_ & 0x00000020) != 0)) {
          result.heartbeatTimeoutInMs_ = heartbeatTimeoutInMs_;
        }
        if (((from_bitField0_ & 0x00000080) != 0)) {
          result.shutdownBarrierTimeoutInMs_ = shutdownBarrierTimeoutInMs_;
        }
        if (((from_bitField0_ & 0x00000100) != 0)) {
          result.agentDestructionWithoutShutdown_ = agentDestructionWithoutShutdown_;
        }
        if (((from_bitField0_ & 0x00000200) != 0)) {
          recoverableJobs_.makeImmutable();
          result.recoverableJobs_ = recoverableJobs_;
        }
        if (((from_bitField0_ & 0x00000400) != 0)) {
          result.allowNewIncarnationToReconnect_ = allowNewIncarnationToReconnect_;
        }
        if (((from_bitField0_ & 0x00000800) != 0)) {
          result.forceDisable_ = forceDisable_;
        }
        if (((from_bitField0_ & 0x00001000) != 0)) {
          result.pollForErrorFromServiceAtStartup_ = pollForErrorFromServiceAtStartup_;
        }
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof org.tensorflow.proto.CoordinationConfig.CoordinationServiceConfig) {
          return mergeFrom((org.tensorflow.proto.CoordinationConfig.CoordinationServiceConfig)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(org.tensorflow.proto.CoordinationConfig.CoordinationServiceConfig other) {
        if (other == org.tensorflow.proto.CoordinationConfig.CoordinationServiceConfig.getDefaultInstance()) return this;
        if (!other.getServiceType().isEmpty()) {
          serviceType_ = other.serviceType_;
          bitField0_ |= 0x00000001;
          onChanged();
        }
        if (!other.getServiceLeader().isEmpty()) {
          serviceLeader_ = other.serviceLeader_;
          bitField0_ |= 0x00000002;
          onChanged();
        }
        if (other.getEnableHealthCheck() != false) {
          setEnableHealthCheck(other.getEnableHealthCheck());
        }
        if (other.getClusterRegisterTimeoutInMs() != 0L) {
          setClusterRegisterTimeoutInMs(other.getClusterRegisterTimeoutInMs());
        }
        if (other.getClusterRegisterWithBarrier() != false) {
          setClusterRegisterWithBarrier(other.getClusterRegisterWithBarrier());
        }
        if (other.getHeartbeatTimeoutInMs() != 0L) {
          setHeartbeatTimeoutInMs(other.getHeartbeatTimeoutInMs());
        }
        if (coordinatedJobListBuilder_ == null) {
          if (!other.coordinatedJobList_.isEmpty()) {
            if (coordinatedJobList_.isEmpty()) {
              coordinatedJobList_ = other.coordinatedJobList_;
              bitField0_ = (bitField0_ & ~0x00000040);
            } else {
              ensureCoordinatedJobListIsMutable();
              coordinatedJobList_.addAll(other.coordinatedJobList_);
            }
            onChanged();
          }
        } else {
          if (!other.coordinatedJobList_.isEmpty()) {
            if (coordinatedJobListBuilder_.isEmpty()) {
              coordinatedJobListBuilder_.dispose();
              coordinatedJobListBuilder_ = null;
              coordinatedJobList_ = other.coordinatedJobList_;
              bitField0_ = (bitField0_ & ~0x00000040);
              coordinatedJobListBuilder_ = 
                com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders ?
                   getCoordinatedJobListFieldBuilder() : null;
            } else {
              coordinatedJobListBuilder_.addAllMessages(other.coordinatedJobList_);
            }
          }
        }
        if (other.getShutdownBarrierTimeoutInMs() != 0L) {
          setShutdownBarrierTimeoutInMs(other.getShutdownBarrierTimeoutInMs());
        }
        if (other.getAgentDestructionWithoutShutdown() != false) {
          setAgentDestructionWithoutShutdown(other.getAgentDestructionWithoutShutdown());
        }
        if (!other.recoverableJobs_.isEmpty()) {
          if (recoverableJobs_.isEmpty()) {
            recoverableJobs_ = other.recoverableJobs_;
            bitField0_ |= 0x00000200;
          } else {
            ensureRecoverableJobsIsMutable();
            recoverableJobs_.addAll(other.recoverableJobs_);
          }
          onChanged();
        }
        if (other.getAllowNewIncarnationToReconnect() != false) {
          setAllowNewIncarnationToReconnect(other.getAllowNewIncarnationToReconnect());
        }
        if (other.getForceDisable() != false) {
          setForceDisable(other.getForceDisable());
        }
        if (other.getPollForErrorFromServiceAtStartup() != false) {
          setPollForErrorFromServiceAtStartup(other.getPollForErrorFromServiceAtStartup());
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                serviceType_ = input.readStringRequireUtf8();
                bitField0_ |= 0x00000001;
                break;
              } // case 10
              case 18: {
                serviceLeader_ = input.readStringRequireUtf8();
                bitField0_ |= 0x00000002;
                break;
              } // case 18
              case 24: {
                enableHealthCheck_ = input.readBool();
                bitField0_ |= 0x00000004;
                break;
              } // case 24
              case 32: {
                clusterRegisterTimeoutInMs_ = input.readInt64();
                bitField0_ |= 0x00000008;
                break;
              } // case 32
              case 40: {
                heartbeatTimeoutInMs_ = input.readInt64();
                bitField0_ |= 0x00000020;
                break;
              } // case 40
              case 56: {
                shutdownBarrierTimeoutInMs_ = input.readInt64();
                bitField0_ |= 0x00000080;
                break;
              } // case 56
              case 64: {
                agentDestructionWithoutShutdown_ = input.readBool();
                bitField0_ |= 0x00000100;
                break;
              } // case 64
              case 74: {
                java.lang.String s = input.readStringRequireUtf8();
                ensureRecoverableJobsIsMutable();
                recoverableJobs_.add(s);
                break;
              } // case 74
              case 82: {
                org.tensorflow.proto.CoordinationConfig.CoordinatedJob m =
                    input.readMessage(
                        org.tensorflow.proto.CoordinationConfig.CoordinatedJob.parser(),
                        extensionRegistry);
                if (coordinatedJobListBuilder_ == null) {
                  ensureCoordinatedJobListIsMutable();
                  coordinatedJobList_.add(m);
                } else {
                  coordinatedJobListBuilder_.addMessage(m);
                }
                break;
              } // case 82
              case 88: {
                allowNewIncarnationToReconnect_ = input.readBool();
                bitField0_ |= 0x00000400;
                break;
              } // case 88
              case 96: {
                forceDisable_ = input.readBool();
                bitField0_ |= 0x00000800;
                break;
              } // case 96
              case 104: {
                pollForErrorFromServiceAtStartup_ = input.readBool();
                bitField0_ |= 0x00001000;
                break;
              } // case 104
              case 112: {
                clusterRegisterWithBarrier_ = input.readBool();
                bitField0_ |= 0x00000010;
                break;
              } // case 112
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private java.lang.Object serviceType_ = "";
      /**
       * <pre>
       * Type of coordination service implementation to enable.
       * For example, setting the service type as "standalone" starts a service
       * instance on the leader task to provide the coordination services such as
       * heartbeats and consistent key-value store.
       * </pre>
       *
       * <code>string service_type = 1;</code>
       * @return The serviceType.
       */
      public java.lang.String getServiceType() {
        java.lang.Object ref = serviceType_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          serviceType_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * Type of coordination service implementation to enable.
       * For example, setting the service type as "standalone" starts a service
       * instance on the leader task to provide the coordination services such as
       * heartbeats and consistent key-value store.
       * </pre>
       *
       * <code>string service_type = 1;</code>
       * @return The bytes for serviceType.
       */
      public com.google.protobuf.ByteString
          getServiceTypeBytes() {
        java.lang.Object ref = serviceType_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          serviceType_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * Type of coordination service implementation to enable.
       * For example, setting the service type as "standalone" starts a service
       * instance on the leader task to provide the coordination services such as
       * heartbeats and consistent key-value store.
       * </pre>
       *
       * <code>string service_type = 1;</code>
       * @param value The serviceType to set.
       * @return This builder for chaining.
       */
      public Builder setServiceType(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        serviceType_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Type of coordination service implementation to enable.
       * For example, setting the service type as "standalone" starts a service
       * instance on the leader task to provide the coordination services such as
       * heartbeats and consistent key-value store.
       * </pre>
       *
       * <code>string service_type = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearServiceType() {
        serviceType_ = getDefaultInstance().getServiceType();
        bitField0_ = (bitField0_ & ~0x00000001);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Type of coordination service implementation to enable.
       * For example, setting the service type as "standalone" starts a service
       * instance on the leader task to provide the coordination services such as
       * heartbeats and consistent key-value store.
       * </pre>
       *
       * <code>string service_type = 1;</code>
       * @param value The bytes for serviceType to set.
       * @return This builder for chaining.
       */
      public Builder setServiceTypeBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        checkByteStringIsUtf8(value);
        serviceType_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }

      private java.lang.Object serviceLeader_ = "";
      /**
       * <pre>
       * Address where the coordination service instance is hosted.
       * </pre>
       *
       * <code>string service_leader = 2;</code>
       * @return The serviceLeader.
       */
      public java.lang.String getServiceLeader() {
        java.lang.Object ref = serviceLeader_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          serviceLeader_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * Address where the coordination service instance is hosted.
       * </pre>
       *
       * <code>string service_leader = 2;</code>
       * @return The bytes for serviceLeader.
       */
      public com.google.protobuf.ByteString
          getServiceLeaderBytes() {
        java.lang.Object ref = serviceLeader_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          serviceLeader_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * Address where the coordination service instance is hosted.
       * </pre>
       *
       * <code>string service_leader = 2;</code>
       * @param value The serviceLeader to set.
       * @return This builder for chaining.
       */
      public Builder setServiceLeader(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        serviceLeader_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Address where the coordination service instance is hosted.
       * </pre>
       *
       * <code>string service_leader = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearServiceLeader() {
        serviceLeader_ = getDefaultInstance().getServiceLeader();
        bitField0_ = (bitField0_ & ~0x00000002);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Address where the coordination service instance is hosted.
       * </pre>
       *
       * <code>string service_leader = 2;</code>
       * @param value The bytes for serviceLeader to set.
       * @return This builder for chaining.
       */
      public Builder setServiceLeaderBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        checkByteStringIsUtf8(value);
        serviceLeader_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }

      private boolean enableHealthCheck_ ;
      /**
       * <pre>
       * Whether to enable the health check mechanism.
       * </pre>
       *
       * <code>bool enable_health_check = 3;</code>
       * @return The enableHealthCheck.
       */
      @java.lang.Override
      public boolean getEnableHealthCheck() {
        return enableHealthCheck_;
      }
      /**
       * <pre>
       * Whether to enable the health check mechanism.
       * </pre>
       *
       * <code>bool enable_health_check = 3;</code>
       * @param value The enableHealthCheck to set.
       * @return This builder for chaining.
       */
      public Builder setEnableHealthCheck(boolean value) {

        enableHealthCheck_ = value;
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Whether to enable the health check mechanism.
       * </pre>
       *
       * <code>bool enable_health_check = 3;</code>
       * @return This builder for chaining.
       */
      public Builder clearEnableHealthCheck() {
        bitField0_ = (bitField0_ & ~0x00000004);
        enableHealthCheck_ = false;
        onChanged();
        return this;
      }

      private long clusterRegisterTimeoutInMs_ ;
      /**
       * <pre>
       * Maximum wait time for all members in the cluster to be registered.
       * </pre>
       *
       * <code>int64 cluster_register_timeout_in_ms = 4;</code>
       * @return The clusterRegisterTimeoutInMs.
       */
      @java.lang.Override
      public long getClusterRegisterTimeoutInMs() {
        return clusterRegisterTimeoutInMs_;
      }
      /**
       * <pre>
       * Maximum wait time for all members in the cluster to be registered.
       * </pre>
       *
       * <code>int64 cluster_register_timeout_in_ms = 4;</code>
       * @param value The clusterRegisterTimeoutInMs to set.
       * @return This builder for chaining.
       */
      public Builder setClusterRegisterTimeoutInMs(long value) {

        clusterRegisterTimeoutInMs_ = value;
        bitField0_ |= 0x00000008;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Maximum wait time for all members in the cluster to be registered.
       * </pre>
       *
       * <code>int64 cluster_register_timeout_in_ms = 4;</code>
       * @return This builder for chaining.
       */
      public Builder clearClusterRegisterTimeoutInMs() {
        bitField0_ = (bitField0_ & ~0x00000008);
        clusterRegisterTimeoutInMs_ = 0L;
        onChanged();
        return this;
      }

      private boolean clusterRegisterWithBarrier_ ;
      /**
       * <pre>
       * Denotes if we should synchronize the agents' register attempts by blocking
       * on a barrier. This is useful for synchronized restarts.
       * </pre>
       *
       * <code>bool cluster_register_with_barrier = 14;</code>
       * @return The clusterRegisterWithBarrier.
       */
      @java.lang.Override
      public boolean getClusterRegisterWithBarrier() {
        return clusterRegisterWithBarrier_;
      }
      /**
       * <pre>
       * Denotes if we should synchronize the agents' register attempts by blocking
       * on a barrier. This is useful for synchronized restarts.
       * </pre>
       *
       * <code>bool cluster_register_with_barrier = 14;</code>
       * @param value The clusterRegisterWithBarrier to set.
       * @return This builder for chaining.
       */
      public Builder setClusterRegisterWithBarrier(boolean value) {

        clusterRegisterWithBarrier_ = value;
        bitField0_ |= 0x00000010;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Denotes if we should synchronize the agents' register attempts by blocking
       * on a barrier. This is useful for synchronized restarts.
       * </pre>
       *
       * <code>bool cluster_register_with_barrier = 14;</code>
       * @return This builder for chaining.
       */
      public Builder clearClusterRegisterWithBarrier() {
        bitField0_ = (bitField0_ & ~0x00000010);
        clusterRegisterWithBarrier_ = false;
        onChanged();
        return this;
      }

      private long heartbeatTimeoutInMs_ ;
      /**
       * <pre>
       * Heartbeat timeout, if a task does not record heartbeat in this time
       * window, it will be considered disconnected.
       * Note: This is also used as a grace period to accept any heartbeats after
       * the agent has disconnected, to account for the lag time between the service
       * recording the state change and the agent stopping heartbeats.
       * </pre>
       *
       * <code>int64 heartbeat_timeout_in_ms = 5;</code>
       * @return The heartbeatTimeoutInMs.
       */
      @java.lang.Override
      public long getHeartbeatTimeoutInMs() {
        return heartbeatTimeoutInMs_;
      }
      /**
       * <pre>
       * Heartbeat timeout, if a task does not record heartbeat in this time
       * window, it will be considered disconnected.
       * Note: This is also used as a grace period to accept any heartbeats after
       * the agent has disconnected, to account for the lag time between the service
       * recording the state change and the agent stopping heartbeats.
       * </pre>
       *
       * <code>int64 heartbeat_timeout_in_ms = 5;</code>
       * @param value The heartbeatTimeoutInMs to set.
       * @return This builder for chaining.
       */
      public Builder setHeartbeatTimeoutInMs(long value) {

        heartbeatTimeoutInMs_ = value;
        bitField0_ |= 0x00000020;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Heartbeat timeout, if a task does not record heartbeat in this time
       * window, it will be considered disconnected.
       * Note: This is also used as a grace period to accept any heartbeats after
       * the agent has disconnected, to account for the lag time between the service
       * recording the state change and the agent stopping heartbeats.
       * </pre>
       *
       * <code>int64 heartbeat_timeout_in_ms = 5;</code>
       * @return This builder for chaining.
       */
      public Builder clearHeartbeatTimeoutInMs() {
        bitField0_ = (bitField0_ & ~0x00000020);
        heartbeatTimeoutInMs_ = 0L;
        onChanged();
        return this;
      }

      private java.util.List<org.tensorflow.proto.CoordinationConfig.CoordinatedJob> coordinatedJobList_ =
        java.util.Collections.emptyList();
      private void ensureCoordinatedJobListIsMutable() {
        if (!((bitField0_ & 0x00000040) != 0)) {
          coordinatedJobList_ = new java.util.ArrayList<org.tensorflow.proto.CoordinationConfig.CoordinatedJob>(coordinatedJobList_);
          bitField0_ |= 0x00000040;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilder<
          org.tensorflow.proto.CoordinationConfig.CoordinatedJob, org.tensorflow.proto.CoordinationConfig.CoordinatedJob.Builder, org.tensorflow.proto.CoordinationConfig.CoordinatedJobOrBuilder> coordinatedJobListBuilder_;

      /**
       * <code>repeated .tensorflow.CoordinatedJob coordinated_job_list = 10;</code>
       */
      public java.util.List<org.tensorflow.proto.CoordinationConfig.CoordinatedJob> getCoordinatedJobListList() {
        if (coordinatedJobListBuilder_ == null) {
          return java.util.Collections.unmodifiableList(coordinatedJobList_);
        } else {
          return coordinatedJobListBuilder_.getMessageList();
        }
      }
      /**
       * <code>repeated .tensorflow.CoordinatedJob coordinated_job_list = 10;</code>
       */
      public int getCoordinatedJobListCount() {
        if (coordinatedJobListBuilder_ == null) {
          return coordinatedJobList_.size();
        } else {
          return coordinatedJobListBuilder_.getCount();
        }
      }
      /**
       * <code>repeated .tensorflow.CoordinatedJob coordinated_job_list = 10;</code>
       */
      public org.tensorflow.proto.CoordinationConfig.CoordinatedJob getCoordinatedJobList(int index) {
        if (coordinatedJobListBuilder_ == null) {
          return coordinatedJobList_.get(index);
        } else {
          return coordinatedJobListBuilder_.getMessage(index);
        }
      }
      /**
       * <code>repeated .tensorflow.CoordinatedJob coordinated_job_list = 10;</code>
       */
      public Builder setCoordinatedJobList(
          int index, org.tensorflow.proto.CoordinationConfig.CoordinatedJob value) {
        if (coordinatedJobListBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureCoordinatedJobListIsMutable();
          coordinatedJobList_.set(index, value);
          onChanged();
        } else {
          coordinatedJobListBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <code>repeated .tensorflow.CoordinatedJob coordinated_job_list = 10;</code>
       */
      public Builder setCoordinatedJobList(
          int index, org.tensorflow.proto.CoordinationConfig.CoordinatedJob.Builder builderForValue) {
        if (coordinatedJobListBuilder_ == null) {
          ensureCoordinatedJobListIsMutable();
          coordinatedJobList_.set(index, builderForValue.build());
          onChanged();
        } else {
          coordinatedJobListBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <code>repeated .tensorflow.CoordinatedJob coordinated_job_list = 10;</code>
       */
      public Builder addCoordinatedJobList(org.tensorflow.proto.CoordinationConfig.CoordinatedJob value) {
        if (coordinatedJobListBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureCoordinatedJobListIsMutable();
          coordinatedJobList_.add(value);
          onChanged();
        } else {
          coordinatedJobListBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <code>repeated .tensorflow.CoordinatedJob coordinated_job_list = 10;</code>
       */
      public Builder addCoordinatedJobList(
          int index, org.tensorflow.proto.CoordinationConfig.CoordinatedJob value) {
        if (coordinatedJobListBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureCoordinatedJobListIsMutable();
          coordinatedJobList_.add(index, value);
          onChanged();
        } else {
          coordinatedJobListBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <code>repeated .tensorflow.CoordinatedJob coordinated_job_list = 10;</code>
       */
      public Builder addCoordinatedJobList(
          org.tensorflow.proto.CoordinationConfig.CoordinatedJob.Builder builderForValue) {
        if (coordinatedJobListBuilder_ == null) {
          ensureCoordinatedJobListIsMutable();
          coordinatedJobList_.add(builderForValue.build());
          onChanged();
        } else {
          coordinatedJobListBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <code>repeated .tensorflow.CoordinatedJob coordinated_job_list = 10;</code>
       */
      public Builder addCoordinatedJobList(
          int index, org.tensorflow.proto.CoordinationConfig.CoordinatedJob.Builder builderForValue) {
        if (coordinatedJobListBuilder_ == null) {
          ensureCoordinatedJobListIsMutable();
          coordinatedJobList_.add(index, builderForValue.build());
          onChanged();
        } else {
          coordinatedJobListBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <code>repeated .tensorflow.CoordinatedJob coordinated_job_list = 10;</code>
       */
      public Builder addAllCoordinatedJobList(
          java.lang.Iterable<? extends org.tensorflow.proto.CoordinationConfig.CoordinatedJob> values) {
        if (coordinatedJobListBuilder_ == null) {
          ensureCoordinatedJobListIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, coordinatedJobList_);
          onChanged();
        } else {
          coordinatedJobListBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <code>repeated .tensorflow.CoordinatedJob coordinated_job_list = 10;</code>
       */
      public Builder clearCoordinatedJobList() {
        if (coordinatedJobListBuilder_ == null) {
          coordinatedJobList_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000040);
          onChanged();
        } else {
          coordinatedJobListBuilder_.clear();
        }
        return this;
      }
      /**
       * <code>repeated .tensorflow.CoordinatedJob coordinated_job_list = 10;</code>
       */
      public Builder removeCoordinatedJobList(int index) {
        if (coordinatedJobListBuilder_ == null) {
          ensureCoordinatedJobListIsMutable();
          coordinatedJobList_.remove(index);
          onChanged();
        } else {
          coordinatedJobListBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <code>repeated .tensorflow.CoordinatedJob coordinated_job_list = 10;</code>
       */
      public org.tensorflow.proto.CoordinationConfig.CoordinatedJob.Builder getCoordinatedJobListBuilder(
          int index) {
        return getCoordinatedJobListFieldBuilder().getBuilder(index);
      }
      /**
       * <code>repeated .tensorflow.CoordinatedJob coordinated_job_list = 10;</code>
       */
      public org.tensorflow.proto.CoordinationConfig.CoordinatedJobOrBuilder getCoordinatedJobListOrBuilder(
          int index) {
        if (coordinatedJobListBuilder_ == null) {
          return coordinatedJobList_.get(index);  } else {
          return coordinatedJobListBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <code>repeated .tensorflow.CoordinatedJob coordinated_job_list = 10;</code>
       */
      public java.util.List<? extends org.tensorflow.proto.CoordinationConfig.CoordinatedJobOrBuilder> 
           getCoordinatedJobListOrBuilderList() {
        if (coordinatedJobListBuilder_ != null) {
          return coordinatedJobListBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(coordinatedJobList_);
        }
      }
      /**
       * <code>repeated .tensorflow.CoordinatedJob coordinated_job_list = 10;</code>
       */
      public org.tensorflow.proto.CoordinationConfig.CoordinatedJob.Builder addCoordinatedJobListBuilder() {
        return getCoordinatedJobListFieldBuilder().addBuilder(
            org.tensorflow.proto.CoordinationConfig.CoordinatedJob.getDefaultInstance());
      }
      /**
       * <code>repeated .tensorflow.CoordinatedJob coordinated_job_list = 10;</code>
       */
      public org.tensorflow.proto.CoordinationConfig.CoordinatedJob.Builder addCoordinatedJobListBuilder(
          int index) {
        return getCoordinatedJobListFieldBuilder().addBuilder(
            index, org.tensorflow.proto.CoordinationConfig.CoordinatedJob.getDefaultInstance());
      }
      /**
       * <code>repeated .tensorflow.CoordinatedJob coordinated_job_list = 10;</code>
       */
      public java.util.List<org.tensorflow.proto.CoordinationConfig.CoordinatedJob.Builder> 
           getCoordinatedJobListBuilderList() {
        return getCoordinatedJobListFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilder<
          org.tensorflow.proto.CoordinationConfig.CoordinatedJob, org.tensorflow.proto.CoordinationConfig.CoordinatedJob.Builder, org.tensorflow.proto.CoordinationConfig.CoordinatedJobOrBuilder> 
          getCoordinatedJobListFieldBuilder() {
        if (coordinatedJobListBuilder_ == null) {
          coordinatedJobListBuilder_ = new com.google.protobuf.RepeatedFieldBuilder<
              org.tensorflow.proto.CoordinationConfig.CoordinatedJob, org.tensorflow.proto.CoordinationConfig.CoordinatedJob.Builder, org.tensorflow.proto.CoordinationConfig.CoordinatedJobOrBuilder>(
                  coordinatedJobList_,
                  ((bitField0_ & 0x00000040) != 0),
                  getParentForChildren(),
                  isClean());
          coordinatedJobList_ = null;
        }
        return coordinatedJobListBuilder_;
      }

      private long shutdownBarrierTimeoutInMs_ ;
      /**
       * <pre>
       * Denotes how long to wait for all coordination agents to reach the barriers
       * (after the first shutdown request) before disconnecting together. If
       * set to 0, no barrier is imposed upon shutdown and each worker can
       * disconnect individually.
       * </pre>
       *
       * <code>int64 shutdown_barrier_timeout_in_ms = 7;</code>
       * @return The shutdownBarrierTimeoutInMs.
       */
      @java.lang.Override
      public long getShutdownBarrierTimeoutInMs() {
        return shutdownBarrierTimeoutInMs_;
      }
      /**
       * <pre>
       * Denotes how long to wait for all coordination agents to reach the barriers
       * (after the first shutdown request) before disconnecting together. If
       * set to 0, no barrier is imposed upon shutdown and each worker can
       * disconnect individually.
       * </pre>
       *
       * <code>int64 shutdown_barrier_timeout_in_ms = 7;</code>
       * @param value The shutdownBarrierTimeoutInMs to set.
       * @return This builder for chaining.
       */
      public Builder setShutdownBarrierTimeoutInMs(long value) {

        shutdownBarrierTimeoutInMs_ = value;
        bitField0_ |= 0x00000080;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Denotes how long to wait for all coordination agents to reach the barriers
       * (after the first shutdown request) before disconnecting together. If
       * set to 0, no barrier is imposed upon shutdown and each worker can
       * disconnect individually.
       * </pre>
       *
       * <code>int64 shutdown_barrier_timeout_in_ms = 7;</code>
       * @return This builder for chaining.
       */
      public Builder clearShutdownBarrierTimeoutInMs() {
        bitField0_ = (bitField0_ & ~0x00000080);
        shutdownBarrierTimeoutInMs_ = 0L;
        onChanged();
        return this;
      }

      private boolean agentDestructionWithoutShutdown_ ;
      /**
       * <pre>
       * If set, agents do not make an explicit Shutdown() call. Service will only
       * find out about the disconnecte agent via stale heartbeats. Used for
       * testing.
       * </pre>
       *
       * <code>bool agent_destruction_without_shutdown = 8;</code>
       * @return The agentDestructionWithoutShutdown.
       */
      @java.lang.Override
      public boolean getAgentDestructionWithoutShutdown() {
        return agentDestructionWithoutShutdown_;
      }
      /**
       * <pre>
       * If set, agents do not make an explicit Shutdown() call. Service will only
       * find out about the disconnecte agent via stale heartbeats. Used for
       * testing.
       * </pre>
       *
       * <code>bool agent_destruction_without_shutdown = 8;</code>
       * @param value The agentDestructionWithoutShutdown to set.
       * @return This builder for chaining.
       */
      public Builder setAgentDestructionWithoutShutdown(boolean value) {

        agentDestructionWithoutShutdown_ = value;
        bitField0_ |= 0x00000100;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * If set, agents do not make an explicit Shutdown() call. Service will only
       * find out about the disconnecte agent via stale heartbeats. Used for
       * testing.
       * </pre>
       *
       * <code>bool agent_destruction_without_shutdown = 8;</code>
       * @return This builder for chaining.
       */
      public Builder clearAgentDestructionWithoutShutdown() {
        bitField0_ = (bitField0_ & ~0x00000100);
        agentDestructionWithoutShutdown_ = false;
        onChanged();
        return this;
      }

      private com.google.protobuf.LazyStringArrayList recoverableJobs_ =
          com.google.protobuf.LazyStringArrayList.emptyList();
      private void ensureRecoverableJobsIsMutable() {
        if (!recoverableJobs_.isModifiable()) {
          recoverableJobs_ = new com.google.protobuf.LazyStringArrayList(recoverableJobs_);
        }
        bitField0_ |= 0x00000200;
      }
      /**
       * <pre>
       * The list of jobs which are recoverable. If a task in this list fails,
       * it will not propagate error to other tasks.
       * If empty, no jobs will be recoverable and every task failure will cause
       * error propagation to other tasks.
       * </pre>
       *
       * <code>repeated string recoverable_jobs = 9;</code>
       * @return A list containing the recoverableJobs.
       */
      public com.google.protobuf.ProtocolStringList
          getRecoverableJobsList() {
        recoverableJobs_.makeImmutable();
        return recoverableJobs_;
      }
      /**
       * <pre>
       * The list of jobs which are recoverable. If a task in this list fails,
       * it will not propagate error to other tasks.
       * If empty, no jobs will be recoverable and every task failure will cause
       * error propagation to other tasks.
       * </pre>
       *
       * <code>repeated string recoverable_jobs = 9;</code>
       * @return The count of recoverableJobs.
       */
      public int getRecoverableJobsCount() {
        return recoverableJobs_.size();
      }
      /**
       * <pre>
       * The list of jobs which are recoverable. If a task in this list fails,
       * it will not propagate error to other tasks.
       * If empty, no jobs will be recoverable and every task failure will cause
       * error propagation to other tasks.
       * </pre>
       *
       * <code>repeated string recoverable_jobs = 9;</code>
       * @param index The index of the element to return.
       * @return The recoverableJobs at the given index.
       */
      public java.lang.String getRecoverableJobs(int index) {
        return recoverableJobs_.get(index);
      }
      /**
       * <pre>
       * The list of jobs which are recoverable. If a task in this list fails,
       * it will not propagate error to other tasks.
       * If empty, no jobs will be recoverable and every task failure will cause
       * error propagation to other tasks.
       * </pre>
       *
       * <code>repeated string recoverable_jobs = 9;</code>
       * @param index The index of the value to return.
       * @return The bytes of the recoverableJobs at the given index.
       */
      public com.google.protobuf.ByteString
          getRecoverableJobsBytes(int index) {
        return recoverableJobs_.getByteString(index);
      }
      /**
       * <pre>
       * The list of jobs which are recoverable. If a task in this list fails,
       * it will not propagate error to other tasks.
       * If empty, no jobs will be recoverable and every task failure will cause
       * error propagation to other tasks.
       * </pre>
       *
       * <code>repeated string recoverable_jobs = 9;</code>
       * @param index The index to set the value at.
       * @param value The recoverableJobs to set.
       * @return This builder for chaining.
       */
      public Builder setRecoverableJobs(
          int index, java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        ensureRecoverableJobsIsMutable();
        recoverableJobs_.set(index, value);
        bitField0_ |= 0x00000200;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The list of jobs which are recoverable. If a task in this list fails,
       * it will not propagate error to other tasks.
       * If empty, no jobs will be recoverable and every task failure will cause
       * error propagation to other tasks.
       * </pre>
       *
       * <code>repeated string recoverable_jobs = 9;</code>
       * @param value The recoverableJobs to add.
       * @return This builder for chaining.
       */
      public Builder addRecoverableJobs(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        ensureRecoverableJobsIsMutable();
        recoverableJobs_.add(value);
        bitField0_ |= 0x00000200;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The list of jobs which are recoverable. If a task in this list fails,
       * it will not propagate error to other tasks.
       * If empty, no jobs will be recoverable and every task failure will cause
       * error propagation to other tasks.
       * </pre>
       *
       * <code>repeated string recoverable_jobs = 9;</code>
       * @param values The recoverableJobs to add.
       * @return This builder for chaining.
       */
      public Builder addAllRecoverableJobs(
          java.lang.Iterable<java.lang.String> values) {
        ensureRecoverableJobsIsMutable();
        com.google.protobuf.AbstractMessageLite.Builder.addAll(
            values, recoverableJobs_);
        bitField0_ |= 0x00000200;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The list of jobs which are recoverable. If a task in this list fails,
       * it will not propagate error to other tasks.
       * If empty, no jobs will be recoverable and every task failure will cause
       * error propagation to other tasks.
       * </pre>
       *
       * <code>repeated string recoverable_jobs = 9;</code>
       * @return This builder for chaining.
       */
      public Builder clearRecoverableJobs() {
        recoverableJobs_ =
          com.google.protobuf.LazyStringArrayList.emptyList();
        bitField0_ = (bitField0_ & ~0x00000200);;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The list of jobs which are recoverable. If a task in this list fails,
       * it will not propagate error to other tasks.
       * If empty, no jobs will be recoverable and every task failure will cause
       * error propagation to other tasks.
       * </pre>
       *
       * <code>repeated string recoverable_jobs = 9;</code>
       * @param value The bytes of the recoverableJobs to add.
       * @return This builder for chaining.
       */
      public Builder addRecoverableJobsBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        checkByteStringIsUtf8(value);
        ensureRecoverableJobsIsMutable();
        recoverableJobs_.add(value);
        bitField0_ |= 0x00000200;
        onChanged();
        return this;
      }

      private boolean allowNewIncarnationToReconnect_ ;
      /**
       * <pre>
       * If a task restarts with a new incarnation, we may allow it to reconnect
       * silently. This is useful when we know that a task can immediately resume
       * work upon re-connecting to the service.
       * </pre>
       *
       * <code>bool allow_new_incarnation_to_reconnect = 11;</code>
       * @return The allowNewIncarnationToReconnect.
       */
      @java.lang.Override
      public boolean getAllowNewIncarnationToReconnect() {
        return allowNewIncarnationToReconnect_;
      }
      /**
       * <pre>
       * If a task restarts with a new incarnation, we may allow it to reconnect
       * silently. This is useful when we know that a task can immediately resume
       * work upon re-connecting to the service.
       * </pre>
       *
       * <code>bool allow_new_incarnation_to_reconnect = 11;</code>
       * @param value The allowNewIncarnationToReconnect to set.
       * @return This builder for chaining.
       */
      public Builder setAllowNewIncarnationToReconnect(boolean value) {

        allowNewIncarnationToReconnect_ = value;
        bitField0_ |= 0x00000400;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * If a task restarts with a new incarnation, we may allow it to reconnect
       * silently. This is useful when we know that a task can immediately resume
       * work upon re-connecting to the service.
       * </pre>
       *
       * <code>bool allow_new_incarnation_to_reconnect = 11;</code>
       * @return This builder for chaining.
       */
      public Builder clearAllowNewIncarnationToReconnect() {
        bitField0_ = (bitField0_ & ~0x00000400);
        allowNewIncarnationToReconnect_ = false;
        onChanged();
        return this;
      }

      private boolean forceDisable_ ;
      /**
       * <pre>
       * Disables coordination service.
       * Some libraries enable coordination service by default even if the user did
       * not specify any config. This field allows users to explicitly disable
       * coordination service under all situations.
       * </pre>
       *
       * <code>bool force_disable = 12;</code>
       * @return The forceDisable.
       */
      @java.lang.Override
      public boolean getForceDisable() {
        return forceDisable_;
      }
      /**
       * <pre>
       * Disables coordination service.
       * Some libraries enable coordination service by default even if the user did
       * not specify any config. This field allows users to explicitly disable
       * coordination service under all situations.
       * </pre>
       *
       * <code>bool force_disable = 12;</code>
       * @param value The forceDisable to set.
       * @return This builder for chaining.
       */
      public Builder setForceDisable(boolean value) {

        forceDisable_ = value;
        bitField0_ |= 0x00000800;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Disables coordination service.
       * Some libraries enable coordination service by default even if the user did
       * not specify any config. This field allows users to explicitly disable
       * coordination service under all situations.
       * </pre>
       *
       * <code>bool force_disable = 12;</code>
       * @return This builder for chaining.
       */
      public Builder clearForceDisable() {
        bitField0_ = (bitField0_ & ~0x00000800);
        forceDisable_ = false;
        onChanged();
        return this;
      }

      private boolean pollForErrorFromServiceAtStartup_ ;
      /**
       * <pre>
       * Use long polling to get error from coordination service as the error
       * propagation mechanism.
       * </pre>
       *
       * <code>bool poll_for_error_from_service_at_startup = 13;</code>
       * @return The pollForErrorFromServiceAtStartup.
       */
      @java.lang.Override
      public boolean getPollForErrorFromServiceAtStartup() {
        return pollForErrorFromServiceAtStartup_;
      }
      /**
       * <pre>
       * Use long polling to get error from coordination service as the error
       * propagation mechanism.
       * </pre>
       *
       * <code>bool poll_for_error_from_service_at_startup = 13;</code>
       * @param value The pollForErrorFromServiceAtStartup to set.
       * @return This builder for chaining.
       */
      public Builder setPollForErrorFromServiceAtStartup(boolean value) {

        pollForErrorFromServiceAtStartup_ = value;
        bitField0_ |= 0x00001000;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Use long polling to get error from coordination service as the error
       * propagation mechanism.
       * </pre>
       *
       * <code>bool poll_for_error_from_service_at_startup = 13;</code>
       * @return This builder for chaining.
       */
      public Builder clearPollForErrorFromServiceAtStartup() {
        bitField0_ = (bitField0_ & ~0x00001000);
        pollForErrorFromServiceAtStartup_ = false;
        onChanged();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:tensorflow.CoordinationServiceConfig)
    }

    // @@protoc_insertion_point(class_scope:tensorflow.CoordinationServiceConfig)
    private static final org.tensorflow.proto.CoordinationConfig.CoordinationServiceConfig DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new org.tensorflow.proto.CoordinationConfig.CoordinationServiceConfig();
    }

    public static org.tensorflow.proto.CoordinationConfig.CoordinationServiceConfig getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<CoordinationServiceConfig>
        PARSER = new com.google.protobuf.AbstractParser<CoordinationServiceConfig>() {
      @java.lang.Override
      public CoordinationServiceConfig parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<CoordinationServiceConfig> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<CoordinationServiceConfig> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public org.tensorflow.proto.CoordinationConfig.CoordinationServiceConfig getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_tensorflow_CoordinatedJob_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_tensorflow_CoordinatedJob_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_tensorflow_CoordinationServiceConfig_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_tensorflow_CoordinationServiceConfig_fieldAccessorTable;

  public static com.google.protobuf.Descriptors.FileDescriptor
      getDescriptor() {
    return descriptor;
  }
  private static  com.google.protobuf.Descriptors.FileDescriptor
      descriptor;
  static {
    java.lang.String[] descriptorData = {
      "\n*xla/tsl/protobuf/coordination_config.p" +
      "roto\022\ntensorflow\"1\n\016CoordinatedJob\022\014\n\004na" +
      "me\030\001 \001(\t\022\021\n\tnum_tasks\030\002 \001(\005\"\367\003\n\031Coordina" +
      "tionServiceConfig\022\024\n\014service_type\030\001 \001(\t\022" +
      "\026\n\016service_leader\030\002 \001(\t\022\033\n\023enable_health" +
      "_check\030\003 \001(\010\022&\n\036cluster_register_timeout" +
      "_in_ms\030\004 \001(\003\022%\n\035cluster_register_with_ba" +
      "rrier\030\016 \001(\010\022\037\n\027heartbeat_timeout_in_ms\030\005" +
      " \001(\003\0228\n\024coordinated_job_list\030\n \003(\0132\032.ten" +
      "sorflow.CoordinatedJob\022&\n\036shutdown_barri" +
      "er_timeout_in_ms\030\007 \001(\003\022*\n\"agent_destruct" +
      "ion_without_shutdown\030\010 \001(\010\022\030\n\020recoverabl" +
      "e_jobs\030\t \003(\t\022*\n\"allow_new_incarnation_to" +
      "_reconnect\030\013 \001(\010\022\025\n\rforce_disable\030\014 \001(\010\022" +
      ".\n&poll_for_error_from_service_at_startu" +
      "p\030\r \001(\010J\004\010\006\020\007Bm\n\024org.tensorflow.protoZUg" +
      "ithub.com/tensorflow/tensorflow/tensorfl" +
      "ow/go/core/protobuf/for_core_protos_go_p" +
      "rotob\006proto3"
    };
    descriptor = com.google.protobuf.Descriptors.FileDescriptor
      .internalBuildGeneratedFileFrom(descriptorData,
        new com.google.protobuf.Descriptors.FileDescriptor[] {
        });
    internal_static_tensorflow_CoordinatedJob_descriptor =
      getDescriptor().getMessageTypes().get(0);
    internal_static_tensorflow_CoordinatedJob_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_tensorflow_CoordinatedJob_descriptor,
        new java.lang.String[] { "Name", "NumTasks", });
    internal_static_tensorflow_CoordinationServiceConfig_descriptor =
      getDescriptor().getMessageTypes().get(1);
    internal_static_tensorflow_CoordinationServiceConfig_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_tensorflow_CoordinationServiceConfig_descriptor,
        new java.lang.String[] { "ServiceType", "ServiceLeader", "EnableHealthCheck", "ClusterRegisterTimeoutInMs", "ClusterRegisterWithBarrier", "HeartbeatTimeoutInMs", "CoordinatedJobList", "ShutdownBarrierTimeoutInMs", "AgentDestructionWithoutShutdown", "RecoverableJobs", "AllowNewIncarnationToReconnect", "ForceDisable", "PollForErrorFromServiceAtStartup", });
    descriptor.resolveAllFeaturesImmutable();
  }

  // @@protoc_insertion_point(outer_class_scope)
}
